# GCC

> 这里主要介绍gcc和gdb调试的内容

## gcc

### 编译过程

编译过程：

- 预处理
- 编译
- 汇编
- 链接

#### 预处理

> .c文件--->.i文件

这个阶段，编译器对`.c`文件进行预处理，得到`.i`文件。预处理的内容主要包扩：

1. 处理宏定义：将代码中的宏定义（使用`#define`指令定义的符号）替换为其实际的值。
2. 处理条件编译：根据条件编译指令（如`#ifdef`、`#ifndef`、`#if`等）来判断哪些代码应该被包含在编译中。
3. 处理包含文件：将`#include`指令包含的头文件内容插入到源文件中，以形成完整的源代码文件。
4. 去除注释

预处理的目的在于让程序更容易被识别，方便后续的词法分析和语法分析

这里主要使用的参数为:

- `-o`：指定输出文件的名称

- `-E`：只经历预处理阶段

例如：我的程序如下

```c
#include <stdio.h>                                                      
#define N 10                                                          
int main()                                                                   
{                                                                            
        for(int i=0;i<N;i++){                                                
                printf("%d\n",i);                                            
        }                                                                    
        printf("hello,world");                                               
        return 0;                                                            
}
```

使用命令

```shell
gcc -E hello.c -o hello.i
```

得到的结果可以验证上述叙述



#### 编译

>.i----->.s

编译的过程，就是使用编译原理过程中的知识。即利用词法分析，语法分析，和语义分析等工具将预处理后的代码生成汇编代码。

- 词法分析：将源代码分解为词法单元（tokens）。
- 语法分析：将词法单元组合成语法树，验证代码是否符合语法规则。
- 语义分析：检查代码中的语义错误，并生成对应的汇编代码。

编译阶段将生成一个汇编代码文件，通常以`.s`作为文件扩展名。

这里主要使用的命令为：

- `-S`：到编译这个步骤就停止了

使用命令

```shell
gcc -S hello.i -o hello.s
```

得到汇编文件



#### 汇编

> .s----->.o

汇编阶段是将编译生成的汇编代码翻译成二进制代码的过程。汇编阶段将生成一个可重定位目标文件，通常以`.o`作为文件扩展名。目标文件包含机器代码和一些附加信息，但还没有解决最终的内存地址。

这个阶段主要用到的参数为：

- `-c`：取消链接，单纯就只是编译源码生成机器代码

```shell
gcc -c hello.s -o hello.o
```



#### 链接

> .o---->.exe(unix下为.out)

链接阶段是将多个可重定位目标文件（构成项目的文件）以及库文件（如果有的话）链接在一起，生成最终的可执行文件。

1. 链接阶段的主要任务包括：

- 解决外部符号引用：将目标文件中对其他文件中定义的符号的引用替换为实际的内存地址。
- 合并代码段和数据段：将多个目标文件中的代码段和数据段合并到一个可执行文件中。
- 加载所需的库文件：将程序依赖的库文件链接到可执行文件中。

链接阶段最终生成一个可执行文件，它包含了完整的机器代码和所需的库函数，可以被操作系统加载并执行。

使用如下命令进行

```shell
gcc hello.c -o hello.out
```



### 多文件编译

当写项目的时候，我们通常需要使用分文件编写的方式来构建项目，如果想将该项目生成一个可执行的文件，那么就需要借助多文件编译的方法。常见的方法有入下两种：

**一次性编译**

```shell
hello_fn.h
hello_fn.c
main.c

#一次性编译
gcc hello_fn.c main.c -o newhello
```

**分布汇编之后链接**

```shell
#独立编译
gcc -Wall -c main.c -o main.o
gcc -Wall -c hello_fn.c -o hello_fn.o
gcc -Wall main.o hello_fn.o -o newhello
```

`-Wall`参数能让`gcc`对源文件代码有问题的地方发出警告，报错让我们能意识到。



### 头文件与库文件

#### 静态库与共享库

在链接的时候，有两种选项，一种是在链接的时候，就将库文件复制到程序之中，另一种是只有当程序需要的时候，向操作系统申请，操作系统才从内存中调用的文件。

**静态库是在链接时被复制并链接到目标程序中的库文件。**静态库的文件扩展名通常是`.a`（Unix-like系统）或`.lib`（Windows系统）。

**动态库是在运行时由操作系统加载到内存中的库文件。它包含了编译后的目标代码，但在程序执行时并不会被合并到可执行文件中，而是在需要时动态加载到内存中。**动态库的文件扩展名通常是`.so`（Unix-like系统）或`.dll`（Windows系统）。

#### 存放位置

系统级头文件一般是安装的软件包或系统库的头文件，它们通常存放在`/usr/include`目录下。这个目录包含了许多C、C++和其他语言的系统库的头文件，如标准库、GTK、OpenGL等。

用户级头文件用于存放用户自己编写的头文件或第三方库的头文件，它们一般存放在用户的家目录下的一个特定目录中。常见的用户级头文件目录是`/usr/local/include`或`/usr/include`（用户级别），用户可以将自己的头文件放在这些目录下。

对于特定项目，项目的头文件可以存放在项目目录中的一个子目录，通常名为`include`。

其他的还可能放置在`/usr/lib`,`usr/local/lib`中



#### 文件的引入

**当编译的时候**

> 当在一个目录下就不用指定了

`-I`参数用于指定编译器在编译过程中搜索头文件的路径。头文件通常包含函数的声明和宏定义等信息。使用`-I`参数可以告诉编译器在指定路径下搜索头文件。

当我们有一个自定义的头文件`myheader.h`，它在`/path/to/include`目录下，你可以使用`-I`参数来指定编译器搜索头文件的路径：

```shell
gcc main.c -o my_program -I/path/to/include
```

`/usr/include`目录一般是不用指定的，但是如果头文件不在`/usr/icnclude`里我们就要用`-I`参数指定了，如果不指定会得到一个”xxxx.h: No such file or directory”的错误。-I参数可以用相对路径，比如头文件在当前 目录，可以用`-I.`来指定。

**当链接的时候**

如果库函数不在默认的库搜索路径中，你需要使用`-L`选项指定库的路径，例如：

```shell
gcc main.c -o my_program -L/path/to/lib -lmylibrary
```

其中`-l`参数用于指定程序要链接的库（`/lib`和`/usr/lib`和`/usr/local/lib`里的库直接用-l参数就能链接），后面应该紧跟着库名。

若不在那三个的库就需要使用`-L`参数引入，`-L`参数后面应该紧跟库文件所在的文件目录。

通过`-L`找到文件夹，`-l`找到具体的库文件





## gdb

GDB是unix下的命令行调试工具。可以用于C,C++,Go,Java等语言。常见的命令如下

### 基本使用

#### 启动和退出

**启动GDB**

使用`gdb + 可执行文件`即可启动gdb调试，采用`-q`参数能忽略前面的一些版本信息看起来较为干净，`-tui`能显示源码和调试页面

例如：

```shell
gbd a.out

gdb -q a.out

gdb -q -tui a.out
```

**退出GDB**

使用`q`就可以退出`gdb`

清屏：`shell clear`



#### 断点

**设置断点**

使用`break(b) 行号`就可以对该行设置断点

使用`break 函数名`可以再函数处设置断点

使用`info breakpoints`就可以查看断点的信息

设置条件断点，例如：`break 行号 if n==6`

>Num： 断点编号
>Disp：断点执行一次之后是否有效（keep：有效 dis：无效）
>Enb： 当前断点是否有效 （y：有效 n：无效）
>Address：内存地址
>What：位置

**删除和其他操作**

| `delete n`           | 删除第n个断点 |
| -------------------- | ------------- |
| `disable n`          | 暂停第n个断点 |
| `enable n`           | 开启第n个断点 |
| `clear n`            | 清除第n个断点 |
| `delete breakpoints` | 删除所有断点  |
| `info breakpoints`   | 查看断点信息  |





#### 调试

**运行程序**

使用`run`或者`r`就可以运行程序，直到遇到了断点或者结束

**调试**

>next(n)：单步执行，遇到函数会跳过，不进入函数
>
>nexti：执行下一条汇编指令
>
>step(s)：单步执行，遇到函数会进入函数
>
>stepi：执行下一条汇编指令
>
>continue(c)：继续执行直到遇到下一个断点或者结束（以断点为单位来进行跳步的）
>
>call 函数名(参数)：调用该函数并返回函数的返回值
>
>until：如果再循环中设置了断点，可以使用until来退出循环体
>
>until 行号：运行至某行
>
>finish：跳出当前函数调用，并返回到调用函数的地方



#### 信息查看

**查看源码**

再调试界面输入`list`或者`l`就可以查看源码

使用`list num1,num2`查看num1到num2之间的代码

`list 函数名`用于显示函数周围的代码

`list 文件名:num1,num2`用于显示指定文件的指定区间代码

**查看信息**

| `print + 变量`      | 用于查看变量的值   |
| ------------------- | ------------------ |
| `display 变量`      | 自动打印变量的值   |
| `whatis + 变量`     | 查看变量的数据类型 |
| `backtrace`或者`bt` | 查看当前调用的堆栈 |
| `set args +参数`    | 设置运行时的参数   |
| `show args`         | 查看设置好的参数   |



#### 其他

`make`：使你能不退出 gdb 就可以重新产生可执行文件

`shell`:使你不离开gdb也能执行unix下的命令

`help`：显示帮助信息



### 学习资料

> 学习资料：
>
> [gdb调试常见命令详细总结（附示例操作）_gdb调试命令大全_快乐的学习的博客-CSDN博客](https://blog.csdn.net/Luckiers/article/details/124568399?ops_request_misc=%7B%22request%5Fid%22%3A%22169131145616800180625216%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169131145616800180625216&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-4-124568399-null-null.142^v92^insert_down28v1&utm_term=gdb调试&spm=1018.2226.3001.4187)
>
> [gdb调试详解_简述gdb调试过程_~青萍之末~的博客-CSDN博客](https://blog.csdn.net/daaikuaichuan/article/details/89791255?ops_request_misc=&request_id=&biz_id=102&utm_term=gdb调试&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-89791255.nonecase&spm=1018.2226.3001.4187)
>
> [GDB调试指南(入门，看这篇够了)_程序猿编码的博客-CSDN博客](https://blog.csdn.net/chen1415886044/article/details/105094688?ops_request_misc=%7B%22request%5Fid%22%3A%22169131145616800180625216%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169131145616800180625216&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105094688-null-null.142^v92^insert_down28v1&utm_term=gdb调试&spm=1018.2226.3001.4187)





















